// Copyright © 2015 Corel Corporation.
// 
// Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and accompanying 
// documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute, and transmit the Software, 
// and to prepare derivative works of the Software, and to permit third-parties to whom the Software is furnished to do so, all 
// subject to the following:
// 
// The copyright notices in the Software and this entire statement, including the above license grant, the original location it was 
// downloaded from, this restriction and the following disclaimer, must be included in all copies of the Software, in whole or in part, 
// and all derivative works of the Software, unless such copies or derivative works are solely in the form of machine-executable object 
// code generated by a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. THE SOFTWARE MAY CONTAIN BUGS, ERRORS AND OTHER 
// PROBLEMS THAT COULD CAUSE SYSTEM FAILURES AND THE USE OF SUCH SOFTWARE IS ENTIRELY AT THE USER’S RISK. IN NO EVENT SHALL THE 
// COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Corel.Interop.VGCore;

namespace CGS
{
	/// <summary>
	/// $safeprojectname$: 
	/// Simple 2-point line tool example. Implements ToolState which
	/// allows CorelDRAW or Corel DESIGNER to call back into the tool.
	/// </summary>
	public class $safeprojectname$ : ToolState
	{
		/// <summary>
		/// Constructor for the tool.
		/// </summary>
		/// <param name="app">Reference to the Application object.</param>
		public $safeprojectname$(Application app)
		{
			Application = app;  // Save the application, we use it to create the new line segment
		}

		/// <summary>
		/// Called when the tool is started.
		/// </summary>
		/// <param name="StateAttributes">State attributes.</param>
		public void OnStartState(ToolStateAttributes stateAttributes)
		{
			// save the state attributes so that we can reuse it later
			currentAttribs = stateAttributes;
			currentAttribs.SetCursor(cdrCursorShape.cdrCursorSmallcrosshair);
			currentAttribs.AllowTempPickState = false;
			//uncomment the next line to use a propertybar
			//currentAttribs.PropertyBarGuid = "$GuidB$";
			ui = Application.CreateOnScreenCurve(); // create the xor'd UI object
		}

		/// <summary>
		/// Called when the tool is exited.
		/// </summary>
		public void OnExitState()
		{
			Reset(); // cleanup, reset UI and variables
		}

		/// <summary>
		/// Returns true if the tool is in a drawing state, false otherwise. Certain operations,
		/// like panning, will function differently when this property returns true.
		/// </summary>
		public bool IsDrawing 
		{ 
			get { return isDrawing; } 
		}

		/// <summary>
		/// Called when the user presses ESCAPE.
		/// </summary>>
		public void OnAbort()
		{
			Reset(); // cleanup, reset UI and variables
		}

		/// <summary>
		/// Called when the user presses ENTER, or in this case, by OnLButtonUp when the left mouse
		/// button is released.
		/// </summary>
		/// <param name="pt">Point when ENTER was pressed.</param>
		public void OnCommit(Point pt)
		{
			if (isDrawing)
			{
				Reset(); // cleanup and reset UI and variable
				Application.ActiveDocument.ActiveLayer.CreateLineSegment(save.x, save.y, pt.x, pt.y);	// create the object
			}
		}

		/// <summary>
		/// This is called when the left mouse button is held in place for a short period of time,
		/// or when the left mouse button is held and the mouse moves a short distance. 'pt' will
		/// contain the point when the mouse button was pressed.
		/// </summary>
		/// <param name="pt">Point when the mouse button was pressed.</param>
		public void OnLButtonDownLeaveGrace(Point pt)
		{
			save = pt;				// save the point from the left mouse down.
			isDrawing = true; // place us into the drawing substate
		}

		/// <summary>
		/// Called when the user releases the left mouse button.
		/// </summary>
		/// <param name="pt">Point when the mouse button was released.</param>
		public void OnLButtonUp(Point pt)
		{
			OnCommit(pt); // forward to OnCommit, which will create the line segment
		}

		/// <summary>
		/// Called when the mouse moves across the view.
		/// </summary>
		/// <param name="pt">Mouse point.</param>
		public void OnMouseMove(Point pt)
		{
			if (isDrawing)
			{
				// update the xor'd line
				ui.SetLine(save.x, save.y, pt.x, pt.y);
				ui.Show();
			}
		}

		/// <summary>
		/// Called for every mouse move. This allows us to adjust the mouse point before it reaches any
		/// of the other functions. The currentAttribs member has helper functions to use the built-in
		/// snapping.
		/// </summary>
		/// <param name="pt">Mouse point.</param>
		/// <param name="handled">Reference to a boolean indicating if the event has been handled or not.</param>
		public void OnSnapMouse(Point pt, ref bool handled)
		{
			handled = isDrawing; // use the default snapping if we are not drawing
			if (isDrawing)
			{
				// if we are drawing, we would like to use the anchored snapping, this will allow the perpendicular and tangent
				// snapping to kick in as well.
				currentAttribs.AnchoredSnapMouse(pt, save);
				// also, we'd like to use the built-in constaints (ctrl key to constrain to 15 degree increments)
				currentAttribs.ConstrainMouse(pt, save);
			}
		}

		/// <summary>
		/// Called when the DELETE key is pressed. We do nothing to use the default behaviour.
		/// </summary>
		/// <param name="handled">Reference to a boolean indicating if the event has been handled or not.</param>
		public void OnDelete(ref bool handled) { }

		/// <summary>
		/// Called when a key is pressed. We do nothing to use the default behavior.
		/// </summary>
		/// <param name="windowsKeyCode">Key code of the key that was pressed.</param>
		/// <param name="handled">Reference to a boolean indicating if the event has been handled or not.</param>
		public void OnKeyDown(int windowsKeyCode, ref bool handled) { }

		/// <summary>
		/// Called when a key is released. We do nothing to use the default behavior.
		/// </summary>
		/// <param name="windowsKeyCode">Key code of the key that was released.</param>
		/// <param name="handled">Reference to a boolean indicating if the event has been handled or not.</param>
		public void OnKeyUp(int windowsKeyCode, ref bool handled) { }
		
		/// <summary>
		/// CAlled when the left mouse button is double-clicked. We do nothing
		/// to use the default behaviour.
		/// </summary>
		/// <param name="pt">Mouse point where the left mouse button was double-clicked.</param>
		public void OnLButtonDblClick(Point pt) { }
		
		/// <summary>
		/// Called when the left mouse button is pressed. We do nothing because the left mouse
		/// button behaviour is handled in OnLButtonDownLeaveGrace.
		/// </summary>
		/// <param name="pt">Mouse point where the left mouse button was pressed.</param>
		public void OnLButtonDown(Point pt) { }
		
		/// <summary>
		/// Called when the left mouse button is clicked. We ddo nothing to use the default
		/// behaviour. The default behaviour is to select the shape beneath the mouse cursor.
		/// </summary>
		/// <param name="pt">Mouse point where the left mouse button was clicked.</param>
		/// <param name="handled">Reference to a boolean indicating if the event has been handled or not.</param>
		public void OnClick(Point pt, ref bool handled) { }
		
		/// <summary>
		/// Called when the right mouse button is pressed. We do nothing to use the default behaviour.
		/// </summary>
		/// <param name="pt">Mouse point where the right mouse button was pressed.</param>
		/// <param name="handled">Reference to a boolean indicating if the event has been handled or not.</param>
		public void OnRButtonDown(Point pt, ref bool handled) { }

		/// <summary>
		/// Called when the right mouse button is released. We do nothing to use the default behaviour, which
		/// is to show the default context menu.
		/// </summary>
		/// <param name="pt">Mouse point where the right mouse button was pressed.</param>
		/// <param name="handled">Reference to a boolean indicating if the event has been handled or not.</param>
		public void OnRButtonUp(Point pt, ref bool handled) { }
		
		/// <summary>
		/// Called when a time event is fired. Use ToolStateAttributes to start and stop timers.
		/// </summary>
		/// <param name="timerId">ID of the timer.</param>
		/// <param name="timeEllapsed">Time elapsed.</param>
		public void OnTimer(int timerId, int timeEllapsed) { }

		/// <summary>
		/// Helper function to hide the UI and reset the isDrawing flag.
		/// </summary>
		private void Reset()
		{
			ui.Hide();
			isDrawing = false;
		}

		Point save;														// save the first point
		OnScreenCurve ui;											// on screen xor'd UI to represent the line we're drawing
		bool isDrawing = false;								// determines if the tool is currently drawing
		ToolStateAttributes currentAttribs;		// save a copy of the state attributes
		Application Application;							// save a copy of the application
	}
}
